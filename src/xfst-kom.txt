! This file is a script for the Xerox xfst interface.
! It gives the morphophonological rules for Komi.


clear stack


! Definition section !
! ================== !


echo << THE DEFININTIONS >>

echo << defining Vow >>

define Vow [ а | и | і | о | ӧ | у | ы | э 
           | А | И | І | О | Ӧ | У | Ы | Э
           | я | и | е | ё | ю ];

define PalVow  [ е | ё | ю | я         ! Cns-initial vowels
               | Е | Ё | Ю | Я ];

echo << defining Cns >>
define Cns [ б | в | г | д | ж | з 
           | Б | В | Г | Д | Ж | З 
           | й | к | л | м | н | п | р | с | т | ф | х | ц 
           | Й | К | Л | М | Н | П | Р | С | Т | Ф | Х | Ц 
           | ч | ш | щ | ъ | ь 
           | Ч | Ш | Щ | Ъ | Ь 
           | к2 | л2 | м2 | т2 
           | К2 | Л2 | М2 | Т2 ] ;

define CnsNotSoft [ б | в | г | д | ж | з 
                  | Б | В | Г | Д | Ж | З 
                  | й | к | л | м | н | п | р | с | т | ф | х | ц 
                  | Й | К | Л | М | Н | П | Р | С | Т | Ф | Х | Ц 
                  | ч | ш | щ | ъ | к2 | л2 | м2 | т2
                  | Ч | Ш | Щ | Ъ | К2 | Л2 | М2 | Т2 ] ;
                  
define CnsBeforeCyri [ б | в | г | ж | й | к | м | п  
                     | Б | Б | Г | Ж | Й | К | М | П       
                     | р | ф | х | ч | ш | щ | к2 | м2 | т2       
                     | Р | Ф | Х | Ч | Ш | Щ | К2 | М2 | Т2 ] ;   
                     ! Only certain cons. are allowed before Cyr i 
      
define Letter [ Vow | Cns ] ;      

define Syll [ ( Cns ) ( Cns ) Vow ( Cns ) ( Cns ) ] ;      ! Hmm, not needed now.

echo << defining Boundary >>

define Boundary %> ;
define Diacritics %^Inf ;
define Dummy [ Boundary | Diacritics ] ;


! Rule section !
! ============ !

! Testcases marked as follows:
! space exclmark euro space upper:lower
! To test: 
! xfst -e "source xfst-kom.txt"
! invert net
! save s
! cat xfst-kom.txt | grep €|cut -d" " -f3|cut -d":" -f1|lookup s

echo << defining the rules >>


! The famous L/V
! --------------

define LtoV [ л -> в || _ [ .#. | %> Cns ] ] ;
 ! These words are underlyingly l, and changed to v.
 !€ ныл>ыс:нылыс
 !€ ныл:ныв
 !€ ныл>сӧ:нывсӧ
 
! Paragogic consonants
! --------------------

  ! These are consonants that are visible in front of vowel-initial suffixes.
  ! Here, we say that 

define mDeletion м -> 0 || н _  [ .#. | %> Cns ] ;
 !€ синм>ыс:синмыс
 !€ синм:син
 !€ синм>сӧ:синсӧ

define kDeletion к -> 0 || [ с | ш | с ь | ч] _ [.#. | %> Cns] ; 
 !€ воск>ыс:воскыс
 !€ воск:вос
 !€ воск>сӧ:воссӧ

define tDeletion т -> 0 || п _ [.#. | %> Cns] ;
 !€ зепт>ыс:зептыс
 !€ зепт:зеп
 !€ зепт>сӧ:зепсӧ

define jDeletion й -> 0 || [б | в | г | д | ж | з | к | м | н | п | р | т | с]
                             _ [.#. | %> Cns] ;
 !€ гобй>ыс:гобйыс
 !€ гобй:гоб
 !€ гобй>сӧ:гобсӧ
 !€ кывй>ыс:кывйыс
 !€ кывй:кыв
 !€ кывй>сӧ:кывсӧ


define jDeletionBeforeA [ й %> а ->   я || Vow _ ,, 
                          й %> а -> ъ я || Cns _ ] ; !2011-10-10
 !€ вый>а:выя
 !€ кывй>а:кывъя


define lDeletion л -> 0 || л _  ь       [ .#. | %> Cns ] ;
 !€ вакулль>ыс:вакулльыс
 !€ вакулль:вакуль
 !€ вакулль>сӧ:вакульсӧ
  
  
define dDeletion д -> 0 || д _ [ь | з]  [ .#. | %> Cns ] ;
 !€ виддз>ыс:виддзыс
 !€ виддз:видз
 !€ виддз>сӧ:видзсӧ
  
!! stopping ы -> 0 2011-01-26
!define WeakVowDeletion ы -> 0 || \[ н ы ] _ %> Vow ;
 ! anything but "ny" may preceede the deleted segment.
 ! Consider this: "ы:0" ы:0 <=> V1: + Cns:* _ %+: V1 ;
 !! LET's remember that this should only affect verb forms
 !! That means the surface vowels я а и і ӧ
 !! Wrong results тӧд where тыӧд should be
 !! Wrong на should be ныа
 !! Absence of "ы" vowel
 !! "ы" vowel is present before
 ! a) _ ны
 ! b) _ 0 ="+Imp+Sg2"
 ! c) _ 0 ="CONNEG"
 
! Working around й%>а => ъя
! We need й -> ъ
! We need а -> я
! Look at VowelPalatalisation, below
! Environment: || [~[ [ з | ч ] | д з ]] [ ь | й ] %> _ ;
! How does this deal with й -> ъ change
! кывъя кыв+N+Der/а+A stem кывъ
! кӧсъя кӧсйыны+V+Ind+Prs+Sg1, кӧсйыны+V+Ind+Fut+Sg1



!define jaSuffixAfterJ й -> ъ || _ %> я ;
 !€ кывй>а:кывъя
 ! This presupposes the rule jDeletionBeforeA, which has essentially 
 ! already taken care of this
 ! ok, let's delete this, eventually.
 
define HardMarkDeletion ъ -> 0 || [ Vow (й) | ь ] %> _ ;
 !€ вой>ъяс:войяс
 !€ выль>ъяс:выльяс
 !€ коми>ъяс:комияс
 !€ автобус>ъяс:автобусъяс

! define VowelPalatalisation  а -> я, о -> ё, у -> ю  || 
!                            [~[ [ з | ч ] | д з ]] [ ь | й ] Vow* %> _ ;
! This VowelPalatalisation looks fishy. Why Vow* ?? We tentatively
! We remove the Vow, suspecting it has worked so far with * - as - zero
! as value, i.e. without vowel. The rule gave йи%>a ==> *йия pro йиа


define VowelPalatalisation  [ а -> я, о -> ё, у -> ю  || 
                            [~[ д з | ч ]] [ ь | й ] %> _ ] ;
 !€ вой>ас:вояс
 !€ озй>ас:озъяс
 !€ ворссь>а:ворсся
 !€ картопель>ас:картопеляс (Px3)
 !€ картопель>ъяс:картопельяс (Pl)
! Have to look for ь>о:ё, 
! ь>у:ю appears in compound words                      

define iPalatalisation [ і -> и || [ Vow | CnsBeforeCyri | ь | д з ] %> _ ] ;

 !€ ворссь>і:ворсси
 !€ ло>і:лои

define SoftMarkDeletion [ ь -> 0 || _ %> [ я | ё | ю | и ] ] ; 
! Testcases: see VowelPalatalisation above
  
define HardMarkPalatalisation ъ -> ь || [ д з | ч ] %> _ ;
 !€ виддз>ъяс:видзьяс


echo << defining cleanup rules >>

define Cleanup ӧ2 -> ӧ, е2 -> е, о2 -> о, к2 -> к, л2 -> л, м2 -> м, т2 -> т,
               Ӧ2 -> Ӧ, Е2 -> Е, О2 -> О, К2 -> К, Л2 -> Л, М2 -> М, Т2 -> Т ;

define Deletion [ %@ -> 0 ] ;

define DummyDeletion [ Dummy -> 0 ] ;

! Then we compose the different rules. !
! ==================================== !

echo << composing different parts >>

read regex [ 
    LtoV
.o. mDeletion
.o. kDeletion
.o. tDeletion
.o. jDeletion
.o. jDeletionBeforeA
.o. lDeletion
.o. dDeletion
!.o. WeakVowDeletion
.o. HardMarkPalatalisation
.o. VowelPalatalisation
.o. iPalatalisation
.o. SoftMarkDeletion
!.o. jaSuffixAfterJ
.o. HardMarkDeletion
.o. Cleanup
.o. Deletion
.o. DummyDeletion 
] ;


